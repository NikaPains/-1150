#include <Servo.h>


//вводим константы
const  float L1 =95;
const  float L2 =95;
//л1 и л2 это длина руки манипулятора
const  float Ya =230; 
const float hs =55;  //высота подставки под манипулятор
const float Zc2 =82;  //длина от одного сервака до другого у руки
float Zc1 =37;  //растояние до стенки от хваталки
float Zcl=37;  //переменная для выкрутки, равная Zc1
//это углы альфа, бета, гамма, дельта, тета
float A=90; 
float B=0;
float V=90;
float D=90;
float T=90;
const float k=0.79;// начальный фактический угол в радианах(45 градусов)
float r=0;  //гипотенуза манипулятора
int array[5]={0,0,0,0,0};

struct servo
{
  int offset;
  Servo s;
};

  //серво объявляем
servo s_x;
servo s_y;
servo s_z;
servo s_Zc1;
servo s_Zc2;



//структура (коорды по х и з)
//тут мы ее объявляем
struct Place
{
  float Xa; //координата х 
  float Za; //координата з
};
//объявление каждого болтика
/*Place odin;
Place dva;
Place tri;
Place chetyre;
Place pyat;
Place shest;
Place sem;
Place vosem;
Place devyat;
Place desyat;
Place odinnadcat;
Place dvenadcat;
Place trinadcat;
Place chetyrnadcat;
Place pyatnadcat;
Place shestnadcat;*/

void home(){
  s_x.s.write(s_x.offset);
  s_y.s.write(s_y.offset);//вниз
  s_z.s.write(s_z.offset);//больше 90 вниз
  s_Zc1.s.write(s_Zc1.offset); //больше 90 вниз
  s_Zc2.s.write(s_Zc2.offset); //меньше 90 влево
}

void setup()
{
  s_x.offset=90;
  s_y.offset=39;
  s_z.offset=90;
  s_Zc1.offset=90;
  s_Zc2.offset=90;
  s_x.s.attach(14);
  s_y.s.attach(15);
  s_z.s.attach(16);
  s_Zc1.s.attach(17);
  s_Zc2.s.attach(18);
  pinMode(14, OUTPUT);
  pinMode(15, OUTPUT);
  pinMode(16, OUTPUT);
  pinMode(17, OUTPUT);
  pinMode(18, OUTPUT);
  pinMode(20, OUTPUT);
  Serial.begin(9600);
  digitalWrite(20, LOW);
  home();
  Serial.println(s_x.offset);
}

void execute(const servo& serv, float difference)
{
          if (difference<0){
              for (int i = serv.s.read(); i<=serv.offset-raznitza; i++)
              {
                serv.s.write(i);
                delay(50);
              }
            }
          else {
            for (int i = serv.s.read(); i>=serv.offset-raznitza; i--)
            {
              serv.s.write(i);
              delay(50);
            }
          }    
}

void doItAction(const servo& servo, float targetRad)
{
  Serial.println(raznitza);
  switch(servo){
    case(s_x):
        {
          int targetDeg=round(degrees(targetRad));
          int raznitza=s_x.offset-targetDeg;
          execute(s_x,raznitza); 
          break;
        }
    case(s_y):
      {
        int targetDeg=round(degrees(targetRad));
        int raznitza=s_y.offset-targetDeg;
        execute(s_y,raznitza); 
        break;
      }
    case(s_z):
      {
        int targetDeg=round(degrees(targetRad));
        int raznitza=s_z.offset-targetDeg;
        execute(s_z,raznitza); 
        break;
      }
    case(s_Zc1):
      {
        int targetDeg=round(degrees(targetRad));
        int raznitza=s_Zc1.offset-targetDeg;
        execute(s_Zc1,raznitza); 
       break;
      }
    case(s_Zc2):
      {
        int targetDeg=round(degrees(targetRad));
        int raznitza=s_Zc2.offset-targetDeg;
        execute(s_Zc2,raznitza); 
       break;
      }
  }
  /*if (raznitza<0){
    for (int i = chet; i<=chet-raznitza; i++)
    {
      servo.s.write(i);
      delay(50);
    }
  }
  else {
    for (int i = chet; i>=chet+raznitza; i--)
    {
      servo.s.write(i);
      delay(50);
    }
  }*/
}

/*void doItAction(const Servo& servo, float targetRad)//функция для поворота с 90 градусов
{
  int targetDeg = round(degrees(targetRad));
    Serial.println(targetDeg);
  if (targetDeg>0 && -45<targetDeg)
    for (int i = 90; i < -targetDeg+90; i++)
    {
      servo.write(i);
      delay(50);
    }
  else
    for (int i = 90; i > targetDeg+90; i--)
    {
      servo.write(i);
      delay(50);
    } 
}

void doAction(const Servo& servo, float targetRad)//функция для поворота с минимальным углом 45градусов
{
  int angle = servo.read();
  int targetDeg = round(degrees(targetRad));
  Serial.println(targetDeg);
  if (angle < targetDeg)
    for (int i = angle; i < targetDeg; i++)
    {
      servo.write(i);
      delay(50);
    }
  else
    for (int i = angle; i > targetDeg; i--)
    {
      servo.write(i);
      delay(50);
    } 
}*/

void action(float x, float z) //начинаем цикл, при этом вводим координаты по х и з
{

  float g=0; //гипотенуза
  float W=0;
  float PRZc2=0;  //проекция Zc2
  float c3=0;  //расстояние до Zc2
  float PRr=0;  //проекция r
  
  V=atan(x/(20-Zc1)); //находим угол поворота относительно з
  PRZc2=Zc2*cos(V); //находим проекцию Zc2
  c3=20-PRZc2-Zc1;  //считаем растояние по оси Y до пересечения с высотой от точки соединения L2 и Zc2 
  PRr=sqrt(c3*c3+(x-Zc2*sin(V))*(x-Zc2*sin(V)));  //находим проекцию гипотенузы
  r=sqrt(PRr*PRr+(z-hs)*(z-hs));  //находим гипотенузу
  A=acos((L1*L1+r*r-L2*L2)/(2*L1*r))+k;  //угол наклона L1
  B=acos((L2*L2+r*r-L1*L1)/(2*L2*r))+k;  //угол наклона L2
  T=acos((L2*L2+r*r-L1*L1)/(2*L2*r));  //угол наклона r
  D=3.14-(acos((z-hs)/r)+T); //находим угол поворота вправо или влево PRZc2
  W=atan((z-hs)/c3);
  A=1,57-A-W+0,68;
}
Place boltArray[] = {60.1, 170.1, 60.1, 49.9, -60.1, 49.9, -60.1, 170.1, 0, 167, 40.3, 150.3, 57, 110, 40.3, 69.7, 0, 53, -40.3, 69.7, -57, 110, -40.3, 150.3, 0, 135, 25, 110, 0, 85, -25, 110}; //массив штоб к ним обращаться 

Place getBolt(int nam)//это функция для получения названия болта
{
  Place bolt = boltArray[nam-1];
  return bolt;
}

bool start = true;
int input;
enum det {checkSerial = 0, checkArray, doActions};
byte determinant =  checkSerial;

int len = 0;
void loop()
{
  if ((determinant == checkSerial)&&(Serial.available()))
  {
    char c = Serial.read();
    if (c == 'k') determinant = checkArray;
  }

  if (determinant == checkArray)
  {
    if (Serial.available())
      for(int index = 0; index < 5; index++)
      {
        int znach=Serial.parseInt();              
        if (!(znach< 1 || znach>16))
        {
          array[index]=znach; 
          Serial.print(array[index]);  
          len++;       
        }
      } 
      if (len > 0) determinant = doActions;
  }
      
  if (determinant == doActions)
    {
      for(int pov=0;pov<=len;pov++){
      input = array[pov];
      
      Place bolt = getBolt(input);
      Zc1=6.4;
      action(bolt.Xa, bolt.Za);  //непосредственно крутим
      DoItAction(s_Zc2,T);
      DoItAction(s_Zc1,D);
      DoItAction(s_z,B);
      DoItAction(s_y,A);
      DoItAction(s_x,V);
      digitalWrite(20, HIGH);
      
      for(int vykrbolt=Zc1; vykrbolt<Zcl+40; vykrbolt+=10){
        Zc1=vykrbolt;
        Place bolt = getBolt(input);
        action(bolt.Xa, bolt.Za);
        
        DoItAction(s_Zc2,T);
        DoItAction(s_Zc1,D);
        DoItAction(s_z,B);
        DoItAction(s_x,V);
        DoItAction(s_y,A);
      }
      Zc1=37;
      digitalWrite(20, LOW);
     }
    }
  Serial.println(determinant);
}
