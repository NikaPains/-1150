#include <Servo.h>

//вводим константы
const  float L1 =18;
const  float L2 =16;
//л1 и л2 это длина руки манипулятора
const  float Ya =20; 
const float hs =0;  //высота подставки под манипулятор
const float Zc1 =0;  //растояние до стенки от хваталки
const float Zc2 =0;  //длина от одного сервака до другого у руки
//это расстояние от точки опоры до стенда
float Xa=15;
float Za=17;
//это углы альфа, бета, гамма, дельта, тета
float A=0; 
float B=0;
float V=0;
float D=0;
float T=0;

float r=0;  //гипотенуза манипулятора
//серво объявляем
Servo s_x;
Servo s_y;
Servo s_z;
Servo s_Zc1;
Servo s_Zc2;
  
//структура (коорды по х и з)
//тут мы ее объявляем
struct Place
{
  float Xa; //координата х 
  float Za; //координата з
};
//объявление каждого болтика
Place odin;
Place dva;
Place tri;
Place chetyre;
Place pyat;
Place shest;
Place sem;
Place vosem;
Place devyat;
Place desyat;
Place odinnadcat;
Place dvenadcat;
Place trinadcat;
Place chetyrnadcat;
Place pyatnadcat;
Place shestnadcat;

void setup()
{
  
  s_x.attach(5);
  s_y.attach(7);
  s_z.attach(6);
  s_Zc1.attach(4);
  s_Zc2.attach(3);
  pinMode(5, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(7, OUTPUT);
  Serial.begin(9600);
//а вот теперь задаем координаты для каждого болтика  

  odin.Xa = 60.1;
  odin.Za = 135.1;
  
  dva.Xa = odin.Xa;
  dva.Za = 14.9;

  tri.Xa = -dva.Xa;
  tri.Za = dva.Za;

  chetyre.Xa = -odin.Xa;
  chetyre.Za = odin.Za;

  pyat.Xa = 0;
  pyat.Za = 132;

  shest.Xa = 40.3;
  shest.Za = 115.3;

  sem.Xa = 57;
  sem.Za = 75;

  vosem.Xa = shest.Xa;
  vosem.Za = 34.7;

  devyat.Xa = 0;
  devyat.Za = 18;

  desyat.Xa = -vosem.Xa;
  desyat.Za = vosem.Za;

  odinnadcat.Xa = -sem.Xa;
  odinnadcat.Za = sem.Za;

  dvenadcat.Xa = -shest.Xa ;
  dvenadcat.Za = shest.Za;

  trinadcat.Xa = 0;
  trinadcat.Za = 100;

  chetyrnadcat.Xa = 25;
  chetyrnadcat.Za = sem.Za;

  pyatnadcat.Xa = 0;
  pyatnadcat.Za = 50;

  shestnadcat.Xa = -chetyrnadcat.Xa;
  shestnadcat.Za = sem.Za;
  //массив штоб к ним обращаться 
}

void action(float x, float z) //начинаем цикл, при этом вводим координаты по х и з
{

  float g=0; 
  //гипотенуза
  float PRZc2=0;  //проекция Zc2
  float c3=0;  //расстояние до Zc2
  float PRr=0;  //проекция r
  float  Y2=sqrt(x*x+Ya*Ya); 
  //расстояние от манипулятора до координаты по х
  V=asin(x/Y2);
  //угол поворота относительно оси з
  g=sqrt(z*z+Ya*Ya); 
  //расстояние от опоры манипулятора до координаты по з
  B=acos((L1*L1+g*g-L2*L2)/(2*L1*g)); 
  //угол наклона л1
  A=acos((L2*L2+g*g-L1*L1)/(2*L2*g)); 
  //угол наклона л2
  V=atan(x/(20-Zc1)); //находим угол поворота относительно з
  PRZc2=Zc2*cos(V); //находим проекцию Zc2
  c3=20-PRZc2-Zc1;  //считаем растояние по оси Y до пересечения с высотой от точки соединения L2 и Zc2 
  PRr=sqrt(c3*c3+(x-Zc2*sin(V))*(x-Zc2*sin(V)));  //находим проекцию гипотенузы
  r=sqrt(PRr*PRr+(z-hs)*(z-hs));  //находим гипотенузу
  A=acos((L1*L1+r*r-L2*L2)/(2*L1*r));  //угол наклона L1
  B=acos((L2*L2+r*r-L1*L1)/(2*L2*r));  //угол наклона L2
  T=acos((L2*L2+r*r-L1*L1)/(2*L2*r));  //угол наклона r
  D=270-(acos((z-hs)/r)+T); //находим угол поворота вправо или влево PRZc2
}
Place boltArray[] = {odin,dva, tri, chetyre, pyat, shest, sem, vosem,
                   devyat, desyat, odinnadcat, dvenadcat, trinadcat, 
                   chetyrnadcat, pyatnadcat, shestnadcat};

Place getBolt(int nam)//это функция для получения названия болта
{
  Place bolt = boltArray[nam-1];
  return bolt;
}


void loop()
{
  //обнуляем серво
  s_x.write(0);
  s_y.write(0);
  s_z.write(0);
  s_Zc1.write(0);
  s_Zc2.write(0);
   
  if (Serial.available()){
    int input = Serial.parseInt();
    if (input>0&&input<17){
      Place bolt = getBolt(input);
      //непосредственно крутим
      action(bolt.Xa, bolt.Za);
      s_x.write(V);
      s_y.write(A);
      s_z.write(B);
      s_Zc1.write(T);
      s_Zc2.write(D);
    }
  } 
}
